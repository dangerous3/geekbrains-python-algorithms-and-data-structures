'''
Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках
домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать,
b. написать 3 варианта кода (один у вас уже есть),
c. проанализировать 3 варианта и выбрать оптимальный,
d. результаты анализа вставить в виде комментариев в файл с кодом
(не забудьте указать, для каких N вы проводили замеры),
e. написать общий вывод: какой из трёх вариантов лучше и почему.

Взятая задача:
Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
Количество элементов (n) вводится с клавиатуры.
'''

# Первый вариант решения
def sum1(n):
    n = int(n)
    sum = 0
    for i in range(1, n + 1):
        an = (((-1) ** (i + 1)) / (2 ** (i - 1)))
        # Вывод элемента последовательности
        # print(f'{i} элемент: {an}')
        sum += an
    return sum
# Конец первого варианта решения

'''
Лучшее время вычисления значений функции sum1() от значений 10, 100 и 1000

 python3 -m timeit -n 1000 -s "import task1" "task1.sum1(10)"   
1000 loops, best of 3: 6.91 usec per loop

python3 -m timeit -n 1000 -s "import task1" "task1.sum1(100)"
1000 loops, best of 3: 82.8 usec per loop

python3 -m timeit -n 1000 -s "import task1" "task1.sum1(1000)"
1000 loops, best of 3: 1.53 msec per loop
'''

# Второй вариант решения
def sum2(n):
    a = 1
    s = 0
    for i in range(n):
        s += a
        a /= -2
    return s
# Конец второго варианта решения

'''
Лучшее время вычисления значений функции sum2() от значений 10, 100 и 1000:

python3 -m timeit -n 1000 -s "import task1" "task1.sum2(10)"
1000 loops, best of 3: 1.2 usec per loop

python3 -m timeit -n 1000 -s "import task1" "task1.sum2(100)"
1000 loops, best of 3: 8.37 usec per loop

python3 -m timeit -n 1000 -s "import task1" "task1.sum2(1000)"
1000 loops, best of 3: 117 usec per loop
'''

'''
Вердикт: из указанных двух реализациях суммы алгоритм, реализованный в функции sum2(), работает быстрее.
'''